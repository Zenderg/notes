# Основная информация о структурах данных

 Big O notation — подсчёт количества элементарных операций с сокращением констант. Если на пальцевом примере, то сложность функции перебора списка от первого элемента до последнего равна O(n), где n — количество элементов списка.

| Big O Notation | 10 элементов                 | 100 элементов                 | 1000 элементов                  |
| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |
| **O(1)**       | 1                            | 1                             | 1                               |
| **O(log N)**   | 3                            | 6                             | 9                               |
| **O(N)**       | 10                           | 100                           | 1000                            |
| **O(N log N)** | 30                           | 600                           | 9000                            |
| **O(N^2)**     | 100                          | 10000                         | 1000000                         |
| **O(2^N)**     | 1024                         | 1.26e+29                      | 1.07e+301                       |
| **O(N!)**      | 3628800                      | 9.3e+157                      | 4.02e+2567                      |

### Содержание:

* [Linked List](#linked-list)
* [Doubly Linked List](#doubly-linked-list)
* [Queue](#queue)
* [Stack](#stack)
* [Hash Table](#hash-table)
* [Heap](#heap)
* [Priority queue](#priority-queue)
* [Trie](#trie)
* [Tree](#tree)
  * [Binary Search Tree](#binary-search-tree)
  * [AVL Tree](#avl-tree)
  * [Red-Black Tree](#red-black-tree)
  * [Segment Tree](#segment-tree)
  * [Fenwick Tree](#fenwick-tree)
* [Graph](#graph)
* [Disjoint Set](#disjoint-set)
* [Bloom Filter](#bloom-filter)

## Linked List

Связный список, содержащий ссылки на следующие объекты. (value, nextLink)

[1, 2, 3] - (54, 2)(22, 3)(21, 0) - в данном случае, ссылка на 0 означает, что данный элемент является последним в списке.

Данная структура позволяет эффективно добавлять и удалять элементы на произвольной позиции в последовательности в процессе итерации. 

| Чтение    | Поиск     | Вставка   | Удаление  |
| :--------: | :-------: | :--------: | :-------: |
| O(n)       | O(n)      | O(1)       | O(1)      |


## Doubly Linked List

Двусвязный список, содержащий ссылки на следующие и предыдушие объекты. (prevLink, value, nextLink)

[1, 2, 3] - (0, 54, 2)(1, 22, 3)(2, 21, 0) - в данном случае, ссылка на 0 означает, что данный элемент является последним или первым в списке.

Данные операции проще и потенциально более эффективны (для некорневых узлов), чем в связном списке - при обходе не нужно следить за предыдущим узлом или повторно обходить список в поиске предыдущего узла, плюс его ссылка может быть изменена. 

| Чтение    | Поиск     | Вставка   | Удаление  |
| :-------: | :-------: | :-------: | :-------: |
| O(n)      | O(n)      | O(1)      | O(1)      |

## Queue

Структура данных, в которой элементы хранятся в порядке их добавления. Организована по принципу FIFO.

##### Основные методы:

- enqueue - добавление новых элементов в начало;
- dequeue - удаление элементов с конца.

##### Дополнительные:

- peek - возвращает первый в очереди элемент.

Очередь является примером линейной структуры данных или последовательной коллекции.

## Stack

Абстрактный тип данных, организованных по принципу LIFO.

##### Основные методы:

- push - добавление элемента в конец;
- pop - удаление последнего элемента.

##### Дополнительные:

- peek - возвращает последний элемент в стеке.

Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю.

## Hash Table

структура данных, реализующая абстрактный тип данных *ассоциативный массив*, т.е. структура, которая
*связывает ключи со значениями*.

В идеале хеш-функция будет присваивать элементу массива уникальный ключ. Однако хеш-функции могут генерировать одинаковый индекс для
нескольких ключей - коллизии.

Существует два варианта решения коллизий - хеш-таблица с цепочками и с открытой адресацией.

- Метод цепочек подразумевает хранение значений, соответствующих одному и тому же индексу в виде связного списка(цепочки).

![Хеш цепочки](https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg)

- Метод открытой адресации помещает значение, для которого получен дублирующий индекс, в первую свободную ячейку.

![Хеш открытая адресация](https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Hash_table_5_0_1_1_1_1_0_SP.svg/380px-Hash_table_5_0_1_1_1_1_0_SP.svg.png)

## Heap

Так называемая куча. Структура данных типа дерево.

##### Типы:

- max-heap

Элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами.

![Max-куча](https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)

- min-heap

Если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами.

![Min-куча](https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png)

Не существует никаких ограничений на кол-во узлов-потомков для узла кучи. Обычно не более двух. Куча является максимально эффективной реализацией абстрактного типа данных, который называется очередью с приоритетом.

Узел на вершине кучи, у которого нет родителей, называется корневым узлом.

## Priority queue

Очередь с приоритетом. Абстрактный тип данных, для каждого элемента вычисляется свой приоритет.

Элемент с высоким приоритетом обслуживается раньше элемента с низким приоритетом. Если два элемента имеют одинаковый приоритет - в соответствии с их порядком в очереди.

Очередь с приоритетом поддерживает две обязательные операции — добавить элемент и извлечь максимум(минимум).

Приоритетные очереди часто реализуются в виде куч(heaps), но они отличаются от них. Очередь приоритетов является абстрактной
концепцией вроде «списка» или «карты»; так же, как список может быть реализован в виде связного списка или массива, так и очередь с приоритетом может быть реализована в виде кучи или множеством других методов, например в виде неупорядоченного массива.

| Бинарная куча | Polling   | Peeking   | Adding    |
| :-----------: | :-------: | :-------: | :-------: |
| O(n)          | O(log(n)) | O(1)      | O(log(n)) |

**polling** - вернуть элемент, в начале очереди, и далить его.

**peeking** - выбор головного узла.

**adding** - добавление нового элемента, согласно уровню приоритетности.

| Удаление | Удаление (хеш таблица) | Содержание | Содержание (хеш таблица) |
| :------: | :--------------------: | :--------: | :----------------------: |
| O(n)     | O(log(n))              | O(n)       | O(1)                     |

## Trie

Префиксное дерево. Упорядоченная древовидная структура данных, используется для хранения динамических множеств или ассоциативных массивов. Ключом обычно выступают строки. Префиксное - поиск осуществляется по префиксам.

В отличие от бинарного дерева, узлы не содержат ключи, соответствующие узлу.

Представляет собой корневое дерево, каждое ребро которого помечено каким-то символом, для любого другого узла разные символы. Некоторые узлы префиксного дерева выделены (на рисунке они подписаны цифрами) и считается, что дерево содержит данную строку-ключ, когда эту строку можно прочитать на пути из корня до некоторого выделенного узла.

Получить ключ можно выписыванием подряд символов, помечающих рёбра на пути от корня до узла. Ключ корня дерева — пустая строка. Часто в выделенных узлах хранят дополнительную информацию, связанную с ключом, и обычно выделенными являются только листья и, возможно, некоторые внутренние узлы.

![Префиксное дерево](https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg)

На рисунке ключи «A», «to», «tea», «ted», «ten», «i», «in», «inn».

## Tree

Иерархическая стрктура с асбстракным типом данных. Которая использует корень (root) и поддеревья детей (children), вместе с взаимосвязанными узлами (nodes). 

Если у детей нет своих детей, тогда их называют листьями (leaves).

![Tree](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg)

### Binary Search Tree

Родители таких деревьев всегда имеют только 2-ух детей. Такая упорядоченная структура позволяет быстро просматривать, удалять и добавлять элементы.

Бинарные деревья поиска всегда находятся в упорядоченном (сортированном) состоянии. Найти элемент в них довольно просто, достаточно просто перемещаться по дереву определнным образом. 

Например: надо проверить наличие числа 6 на дереве ниже. Справа - больше, слева - меньше. Пермещение идет от корня. 8 == 6? Нет. 8 < 6? Нет, перемещаемся к левому узлу. 3 == 6? Нет. 3 < 6? Да, перемещаемся вправо. И так продолжается до тех пор, пока не найдется число, или окажется, что его нет. Это позволяет обходить только половину дерева.

![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)

Размер дерева - 9, глубина - 3, корень - 8.

Новые элементы дерева всегда добавляются как листья.

| Доступ    | Поиск     | Вставка   | Удаление  |
| :-------: | :-------: | :-------: | :-------: |
| O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) |

### AVL Tree

Это самобалансирующее бинарное дерево. Высоты 2 дочерних поддеревьев любого узла, отличаются не более чем на один элемент. Если больше, то производится ребалансировка AVL дерева. Удаление и вставка занимают примерно O(log(n)). При это, дерево может ребалансироваться несколько раз.

![AVL Tree](https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif)

Такое дерево следует использовать, если происходит больше чтения, чем изменения. Изменения требуют немного больше времени в отличии от красно-черного дерева, но скорость чтения выше.

### Red-Black Tree

Это разновидность самобалансирующегося бинарного дерева. Каждый узел в таком дереве имеет свой цвет (черный или красный). Цвета используются для сохранения баланса в дереве.

Вставка, удаление, поиск - O(log(n)).

**Свойства:**

- Каждый узел дерева должен быть красным или черным.
- Корень черный.
- Все листья (NIL) черные.
- Если узел красный, то дочерние элементы черные.
- Каждый путь от корневого узла к любому из его дочерних узлов NIL содержит одинаковое количество черных узлов.

Число черных узлов от корня до узла - черная глубина(black depth). Кол-во черных узлов во всех путях от корня до листов называется - черная высота(black-height).


Путь от корня до самого дальнего листа не более чем в два раза длиннее пути от корня до ближайшего листа.

#### Если родитель красый:

![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase2.png)

#### Если родитель черный:

- Left Left Case (`p`левый ребенок `g` и `x` левый ребенок `p`)
- Left Right Case (`p` левый ребенок `g` и `x` правый ребенок `p`)
- Right Right Case (`p` правый ребенок `g` и `x` правый ребенок `p`)
- Right Left Case (`p` правый ребенок `g` и `x` левый ребенок `p`)

#### Left Left Case (g, p, x):

![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3a1.png)

#### Left Right Case (g, p, x):

![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3b.png)

#### Right Right Case (g, p, x):

![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3c.png)

#### Right Left Case (g, p, x):

![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3d.png)

С помощью такого подхода балнсировки, это дерево лучше всего использовать, если требуется постоянно вносить изменения, но по прежнему получать быстрый доступ к элементам.


### Segment Tree

Дерево сегментов, также известное как дерево статистики - древовидная структура данных, которая используется для хранения информации об интервалах, или сегментах. Это позволяет запрашивать, какие из сохраненных сегментов содержатся в данный момент. Принцип статичной структуры (не может быть изменена после ее создания). 

Дерево сегментов - бинарное. Корень представляет собой весь массив, 2 дочерних элемента корня - 2 половины массива и т.д. Поэтому, все элементы массива будут являться листьями такого дерева.

Строится оно снизу вверх со значениями каждого узла, начиная от минимального (или любого другого) значение дочерних элементов. Это занимает O(n log n). Число завершенных операций - это высота дерева (O(log n)).

![Min Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/RangeMinimumQuery.png)

![Sum Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/segment-tree1.png)

Такие деревья используются в областях вычислительной геометрии, и географических информационных системах.

### Fenwick Tree

Структура данных, которая позволяет эффективно обновлять элементы и может выполнить любую коммутативную операцию.

В сравнении с плоским числовым массимвом, дерево Фeнвика достигает лучшего баланса между двумя операциями: обновление элемента и вычисление префиксной суммы. В плоском массиве для этих дествий - O(n). В то время как в дереве Фeнвика - O(log n). Это достигает путем представления чисел как дерева, где значение каждого узла это сумма чисел в поддереве.

Бинарное индексированное дерево представленно в виде массива. Каждый узел хранит сумму нескольких элементов заданного массива. Размер дерева соответсвует размеру входного массива. В данном случае используется размер `n+1` для упрощения реализации.

![Binary Indexed Tree](https://www.geeksforgeeks.org/wp-content/uploads/BITSum.png)

## Graph

Граф - абстрактный тип данных, состоящий из конечного (и возможно изменяющегося) набора вершин, узлов, или точек, совместный с 
набором направленных или ненаправленных пар вершин. Эти пары еще называют ребрами (линиями) для ненаправленного графа, или направленные ребра (стрелки) для направленного графа.

Многие структуры, представляющие практический интерес в математике и информатике, могут быть представлены графами. Например, строение Википедии можно смоделировать при помощи ориентированного графа, в котором вершины — это статьи, а дуги (ориентированные рёбра) — гиперссылки.

![Граф](https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg)

## Disjoint Set

Система непересекающихся множеств - это структура данных, которая управляет множеством элементов, разбитых на несколько непересекающихся подмножеств. Она предоставляет около-константное время выполнения операций по **добавлению
новых множеств**, **слиянию существующих множеств** и **опеределению, относятся ли элементы к одному и тому же множеству**.

Применяется для хранения компонент связности в графах, в частности, алгоритму Краскала необходима подобная структура
данных для эффективной реализации.

Основные операции:

- **MakeSet(x)** - создаёт одноэлементное множество {x},
- **Find(x)** - возвращает идентификатор множества, содержащего элемент x,
- **Union(x,y)** - объединение множеств, содержащих x и y.

После некоторых операций *объединения*, некоторые множества собраны вместе.

## Bloom Filter

**Фильтр Блума** - это пространственно-эффективная вероятностная структура данных, созданная для проверки наличия элемента
в множестве. Он спроектирован невероятно быстрым при минимальном использовании памяти ценой потенциальных ложных срабатываний. Очередь возвращает или "возможно в наборе", или "определённо не в наборе". Фильтр Блума может использовать любой объём памяти, однако чем он больше, тем меньше вероятность ложного срабатывания. 

Блум предложил эту технику для применения в областях, где количество исходных данных потребовало бы непрактично много 
памяти, в случае применения условно безошибочных техник хеширования.

Фильтр Блума может быть использован для блогов. Если цель состоит в том, чтобы показать читателям только те статьи, которые они ещё не видели, фильтр блума идеален. Он может содержать хешированные значения, соответствующие статье. После того, как пользователь прочитал несколько статей, они могут быть помещены в фильтр. В следующий раз, когда пользователь посетит сайт, эти статьи могут быть убраны из результатов с помощью фильтра.

Некоторые статьи неизбежно будут отфильтрованы по ошибке, но цена приемлема. То, что пользователь не увидит несколько статей в полне приемлемо, принимая во внимание тот факт, что ему всегда показываются другие новые статьи при каждом новом посещении.
